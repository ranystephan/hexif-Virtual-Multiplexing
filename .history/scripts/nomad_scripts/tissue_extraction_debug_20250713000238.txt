{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Tissue Extraction Debug Notebook\n",
    "\n",
    "This notebook helps debug why SPACEc is finding 0 tissue pieces in your CODEX data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import libraries\n",
    "import sys\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "import spacec as sp\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from pathlib import Path\n",
    "import pandas as pd\n",
    "from skimage import filters, morphology, measure\n",
    "\n",
    "print(\"Libraries imported successfully\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Find a qptiff file to test\n",
    "data_root = Path(\"../../data/nomad_data/CODEX\")\n",
    "\n",
    "# Find TMA directories\n",
    "tma_dirs = [d for d in data_root.iterdir() if d.is_dir() and \"TMA\" in d.name]\n",
    "print(f\"Found {len(tma_dirs)} TMA directories\")\n",
    "\n",
    "# Use the first TMA\n",
    "tma_dir = tma_dirs[0]\n",
    "print(f\"Using TMA: {tma_dir.name}\")\n",
    "\n",
    "# Find qptiff files\n",
    "scan_dir = tma_dir / \"Scan1\"\n",
    "qptiff_files = list(scan_dir.glob(\"*.qptiff\"))\n",
    "print(f\"Found {len(qptiff_files)} qptiff files\")\n",
    "\n",
    "# Use the first qptiff file\n",
    "qptiff_file = qptiff_files[0]\n",
    "print(f\"Using file: {qptiff_file.name}\")\n",
    "\n",
    "# Create output directory\n",
    "output_dir = Path(\"../../data/nomad_data/CODEX/debug_output\")\n",
    "output_dir.mkdir(parents=True, exist_ok=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Step 1: Downscale the image\n",
    "print(\"Step 1: Downscaling image...\")\n",
    "resized_im = sp.hf.downscale_tissue(\n",
    "    file_path=str(qptiff_file),\n",
    "    downscale_factor=64,\n",
    "    padding=50,\n",
    "    output_dir=str(output_dir)\n",
    ")\n",
    "\n",
    "print(f\"Downscaled image shape: {resized_im.shape}\")\n",
    "print(f\"Downscaled image dtype: {resized_im.dtype}\")\n",
    "print(f\"Downscaled image min/max: {resized_im.min():.3f}/{resized_im.max():.3f}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Step 2: Analyze image intensity distribution\n",
    "print(\"Step 2: Analyzing intensity distribution...\")\n",
    "\n",
    "if len(resized_im.shape) == 3:\n",
    "    print(\"Multi-channel image detected\")\n",
    "    for i in range(min(5, resized_im.shape[0])):  # Look at first 5 channels\n",
    "        channel = resized_im[i]\n",
    "        print(f\"Channel {i}: min={channel.min():.3f}, max={channel.max():.3f}, mean={channel.mean():.3f}\")\n",
    "    \n",
    "    # Use first channel for analysis\n",
    "    tissue_channel = resized_im[0]\n",
    "else:\n",
    "    print(\"Single-channel image detected\")\n",
    "    print(f\"Intensity: min={resized_im.min():.3f}, max={resized_im.max():.3f}, mean={resized_im.mean():.3f}\")\n",
    "    tissue_channel = resized_im\n",
    "\n",
    "# Plot histogram\n",
    "plt.figure(figsize=(12, 4))\n",
    "\n",
    "plt.subplot(1, 3, 1)\n",
    "plt.hist(tissue_channel.flatten(), bins=100, alpha=0.7)\n",
    "plt.title('Intensity Histogram')\n",
    "plt.xlabel('Intensity')\n",
    "plt.ylabel('Frequency')\n",
    "\n",
    "plt.subplot(1, 3, 2)\n",
    "plt.imshow(tissue_channel, cmap='gray')\n",
    "plt.title('Tissue Channel')\n",
    "plt.colorbar()\n",
    "\n",
    "plt.subplot(1, 3, 3)\n",
    "plt.imshow(tissue_channel, cmap='viridis')\n",
    "plt.title('Tissue Channel (Viridis)')\n",
    "plt.colorbar()\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Step 3: Try different cutoff values systematically\n",
    "print(\"Step 3: Testing different cutoff values...\")\n",
    "\n",
    "# Create systematic cutoff combinations\n",
    "lower_cutoffs = np.linspace(0.01, 0.5, 10)  # 10 values from 0.01 to 0.5\n",
    "upper_cutoffs = np.linspace(0.5, 0.99, 10)  # 10 values from 0.5 to 0.99\n",
    "\n",
    "results = []\n",
    "best_n_tissues = 0\n",
    "best_params = None\n",
    "\n",
    "print(f\"Testing {len(lower_cutoffs)} x {len(upper_cutoffs)} = {len(lower_cutoffs) * len(upper_cutoffs)} combinations\")\n",
    "\n",
    "for i, lower_cutoff in enumerate(lower_cutoffs):\n",
    "    for j, upper_cutoff in enumerate(upper_cutoffs):\n",
    "        # Skip invalid combinations (lower >= upper)\n",
    "        if lower_cutoff >= upper_cutoff:\n",
    "            continue\n",
    "        \n",
    "        try:\n",
    "            tissueframe = sp.tl.label_tissue(\n",
    "                resized_im,\n",
    "                lower_cutoff=lower_cutoff,\n",
    "                upper_cutoff=upper_cutoff\n",
    "            )\n",
    "            \n",
    "            unique_regions = tissueframe['region'].unique()\n",
    "            n_tissues = len([r for r in unique_regions if r != 0])  # Exclude background\n",
    "            \n",
    "            results.append({\n",
    "                'lower_cutoff': lower_cutoff,\n",
    "                'upper_cutoff': upper_cutoff,\n",
    "                'n_tissues': n_tissues\n",
    "            })\n",
    "            \n",
    "            # Track the best result\n",
    "            if n_tissues > best_n_tissues:\n",
    "                best_n_tissues = n_tissues\n",
    "                best_params = (lower_cutoff, upper_cutoff)\n",
    "                print(f\"New best: {n_tissues} tissues with cutoffs ({lower_cutoff:.3f}, {upper_cutoff:.3f})\")\n",
    "            \n",
    "        except Exception as e:\n",
    "            print(f\"Failed with cutoffs ({lower_cutoff:.3f}, {upper_cutoff:.3f}): {e}\")\n",
    "            results.append({\n",
    "                'lower_cutoff': lower_cutoff,\n",
    "                'upper_cutoff': upper_cutoff,\n",
    "                'n_tissues': 0\n",
    "            })\n",
    "\n",
    "print(f\"\\nBest result: {best_n_tissues} tissues with cutoffs {best_params}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Step 4: Analyze results\n",
    "print(\"Step 4: Analyzing results...\")\n",
    "\n",
    "results_df = pd.DataFrame(results)\n",
    "print(f\"Total combinations tested: {len(results_df)}\")\n",
    "print(f\"Combinations with tissues: {len(results_df[results_df['n_tissues'] > 0])}\")\n",
    "\n",
    "if len(results_df[results_df['n_tissues'] > 0]) > 0:\n",
    "    # Show top results\n",
    "    top_results = results_df.nlargest(10, 'n_tissues')\n",
    "    print(\"\\nTop 10 results:\")\n",
    "    print(top_results)\n",
    "    \n",
    "    # Create heatmap\n",
    "    plt.figure(figsize=(10, 8))\n",
    "    \n",
    "    # Create pivot table for heatmap\n",
    "    pivot_data = results_df.pivot_table(\n",
    "        values='n_tissues', \n",
    "        index='lower_cutoff', \n",
    "        columns='upper_cutoff', \n",
    "        fill_value=0\n",
    "    )\n",
    "    \n",
    "    # Plot heatmap\n",
    "    plt.imshow(pivot_data.values, cmap='viridis', aspect='auto', \n",
    "               extent=[pivot_data.columns.min(), pivot_data.columns.max(),\n",
    "                      pivot_data.index.min(), pivot_data.index.max()])\n",
    "    \n",
    "    plt.colorbar(label='Number of Tissue Pieces')\n",
    "    plt.xlabel('Upper Cutoff')\n",
    "    plt.ylabel('Lower Cutoff')\n",
    "    plt.title('Tissue Extraction Results')\n",
    "    \n",
    "    # Add best result marker\n",
    "    if best_params:\n",
    "        plt.scatter(best_params[1], best_params[0], \n",
    "                   color='red', s=100, marker='*', \n",
    "                   label=f'Best: {best_n_tissues} tissues')\n",
    "        plt.legend()\n",
    "    \n",
    "    plt.show()\n",
    "else:\n",
    "    print(\"No tissue pieces found with any combination!\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Step 5: Try manual thresholding if SPACEc fails\n",
    "print(\"Step 5: Trying manual thresholding...\")\n",
    "\n",
    "if best_n_tissues == 0:\n",
    "    print(\"SPACEc found no tissues, trying manual approach...\")\n",
    "    \n",
    "    # Apply Otsu thresholding\n",
    "    threshold = filters.threshold_otsu(tissue_channel)\n",
    "    print(f\"Otsu threshold: {threshold:.3f}\")\n",
    "    \n",
    "    tissue_mask = tissue_channel > threshold\n",
    "    \n",
    "    # Clean up the mask\n",
    "    tissue_mask = morphology.remove_small_objects(tissue_mask, min_size=100)\n",
    "    tissue_mask = morphology.binary_closing(tissue_mask)\n",
    "    \n",
    "    # Label connected components\n",
    "    labeled_mask = measure.label(tissue_mask)\n",
    "    n_regions = len(np.unique(labeled_mask)) - 1  # Exclude background\n",
    "    \n",
    "    print(f\"Manual thresholding found {n_regions} regions\")\n",
    "    \n",
    "    # Visualize results\n",
    "    plt.figure(figsize=(15, 5))\n",
    "    \n",
    "    plt.subplot(1, 3, 1)\n",
    "    plt.imshow(tissue_channel, cmap='gray')\n",
    "    plt.title('Original Image')\n",
    "    plt.colorbar()\n",
    "    \n",
    "    plt.subplot(1, 3, 2)\n",
    "    plt.imshow(tissue_mask, cmap='gray')\n",
    "    plt.title(f'Tissue Mask (Otsu threshold: {threshold:.3f})')\n",
    "    \n",
    "    plt.subplot(1, 3, 3)\n",
    "    plt.imshow(labeled_mask, cmap='tab20')\n",
    "    plt.title(f'Labeled Regions ({n_regions} regions)')\n",
    "    plt.colorbar()\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    if n_regions > 0:\n",
    "        print(\"SUCCESS! Manual thresholding worked\")\n",
    "    else:\n",
    "        print(\"Manual thresholding also failed\")\n",
    "else:\n",
    "    print(\"SPACEc found tissues, manual thresholding not needed\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Step 6: Test the best parameters if found\n",
    "if best_params and best_n_tissues > 0:\n",
    "    print(f\"Step 6: Testing best parameters: {best_params}\")\n",
    "    \n",
    "    try:\n",
    "        # Extract tissues with best parameters\n",
    "        tissueframe = sp.tl.label_tissue(\n",
    "            resized_im,\n",
    "            lower_cutoff=best_params[0],\n",
    "            upper_cutoff=best_params[1]\n",
    "        )\n",
    "        \n",
    "        # Extract individual tissues\n",
    "        extracted_tissues = []\n",
    "        unique_regions = tissueframe['region'].unique()\n",
    "        \n",
    "        for region in unique_regions:\n",
    "            if region != 0:  # Skip background\n",
    "                try:\n",
    "                    sp.tl.save_labelled_tissue(\n",
    "                        filepath=str(qptiff_file),\n",
    "                        tissueframe=tissueframe,\n",
    "                        output_dir=str(output_dir),\n",
    "                        downscale_factor=64,\n",
    "                        region=region,\n",
    "                        padding=50\n",
    "                    )\n",
    "                    \n",
    "                    # Find the extracted tissue file\n",
    "                    tissue_files = list(output_dir.glob(f\"reg{region:03d}_*.tif\"))\n",
    "                    if tissue_files:\n",
    "                        extracted_tissues.extend(tissue_files)\n",
    "                        \n",
    "                except Exception as e:\n",
    "                    print(f\"Error extracting tissue region {region}: {e}\")\n",
    "                    continue\n",
    "        \n",
    "        print(f\"Successfully extracted {len(extracted_tissues)} tissue pieces\")\n",
    "        \n",
    "        # List extracted files\n",
    "        for tissue_file in extracted_tissues:\n",
    "            print(f\"  - {tissue_file.name}\")\n",
    "            \n",
    "    except Exception as e:\n",
    "        print(f\"Error testing best parameters: {e}\")\n",
    "else:\n",
    "    print(\"No best parameters to test\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Step 7: Summary and recommendations\n",
    "print(\"Step 7: Summary and recommendations\")\n",
    "print(\"=\" * 50)\n",
    "\n",
    "if best_n_tissues > 0:\n",
    "    print(f\"✓ SUCCESS: Found {best_n_tissues} tissue pieces\")\n",
    "    print(f\"  Best parameters: lower_cutoff={best_params[0]:.3f}, upper_cutoff={best_params[1]:.3f}\")\n",
    "    print(f\"  Use these parameters in your SPACEc pipeline\")\n",
    "elif 'n_regions' in locals() and n_regions > 0:\n",
    "    print(f\"✓ PARTIAL SUCCESS: Manual thresholding found {n_regions} regions\")\n",
    "    print(f\"  SPACEc's built-in function failed, but manual approach worked\")\n",
    "    print(f\"  Consider using manual thresholding as fallback\")\n",
    "else:\n",
    "    print(\"✗ FAILURE: No tissue pieces found with any method\")\n",
    "    print(\"  Possible issues:\")\n",
    "    print(\"  1. Image quality or contrast issues\")\n",
    "    print(\"  2. Tissue pieces are too small or too large\")\n",
    "    print(\"  3. Image preprocessing needed\")\n",
    "    print(\"  4. Different downscale_factor needed\")\n",
    "\n",
    "print(\"\\nNext steps:\")\n",
    "print(\"1. If successful, use the best parameters in your pipeline\")\n",
    "print(\"2. If manual thresholding worked, implement it as fallback\")\n",
    "print(\"3. If both failed, check image quality and preprocessing\")\n",
    "print(\"4. Try different downscale_factor values\")\n",
    "print(\"5. Consider image enhancement techniques\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}