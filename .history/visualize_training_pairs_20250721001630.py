"""
Visualize Training Pairs from Registration Pipeline

This script loads and visualizes training pairs generated by the registration pipeline
to verify data quality, alignment, and ensure proper H&E to multiplex protein pairing.
"""

import os
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
import random
from typing import List, Tuple
import cv2
from matplotlib.patches import Rectangle

def load_training_pair(he_path: str, orion_path: str) -> Tuple[np.ndarray, np.ndarray]:
    """Load a training pair from numpy files."""
    he_patch = np.load(he_path)
    orion_patch = np.load(orion_path)
    return he_patch, orion_patch

def find_training_pairs(pairs_dir: str, max_pairs: int = 20) -> List[Tuple[str, str, str]]:
    """Find training pairs in the directory."""
    pairs_path = Path(pairs_dir)
    
    # Find all HE files
    he_files = list(pairs_path.glob("*_HE.npy"))
    
    pairs = []
    for he_file in he_files:
        # Get corresponding Orion file
        orion_file = he_file.parent / he_file.name.replace("_HE.npy", "_ORION.npy")
        
        if orion_file.exists():
            # Extract patch ID for labeling
            patch_id = he_file.stem.replace("_HE", "")
            pairs.append((str(he_file), str(orion_file), patch_id))
    
    # Randomly sample pairs if too many
    if len(pairs) > max_pairs:
        pairs = random.sample(pairs, max_pairs)
    
    return pairs

def normalize_for_display(img: np.ndarray) -> np.ndarray:
    """Normalize image for display."""
    if img.dtype != np.uint8:
        img_norm = cv2.normalize(img, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)
    else:
        img_norm = img.copy()
    
    return img_norm

def create_overlay(he_img: np.ndarray, orion_img: np.ndarray) -> np.ndarray:
    """Create overlay of H&E and Orion for alignment checking."""
    # Convert H&E to grayscale if needed
    if he_img.ndim == 3:
        he_gray = cv2.cvtColor(he_img, cv2.COLOR_RGB2GRAY)
    else:
        he_gray = he_img
    
    # Normalize both images
    he_norm = normalize_for_display(he_gray)
    orion_norm = normalize_for_display(orion_img)
    
    # Create RGB overlay: H&E in red, Orion in green
    overlay = np.zeros((he_norm.shape[0], he_norm.shape[1], 3), dtype=np.uint8)
    overlay[:, :, 0] = he_norm  # Red channel
    overlay[:, :, 1] = orion_norm  # Green channel
    
    return overlay

def analyze_patch_content(he_patch: np.ndarray, orion_patch: np.ndarray) -> dict:
    """Analyze patch content for quality assessment."""
    analysis = {}
    
    # H&E analysis
    he_mean = np.mean(he_patch)
    he_std = np.std(he_patch)
    he_contrast = he_std / he_mean if he_mean > 0 else 0
    
    analysis['he'] = {
        'mean_intensity': he_mean,
        'std_intensity': he_std,
        'contrast_ratio': he_contrast,
        'shape': he_patch.shape
    }
    
    # Orion analysis
    orion_mean = np.mean(orion_patch)
    orion_std = np.std(orion_patch)
    orion_max = np.max(orion_patch)
    orion_contrast = orion_std / orion_mean if orion_mean > 0 else 0
    
    analysis['orion'] = {
        'mean_intensity': orion_mean,
        'std_intensity': orion_std,
        'max_intensity': orion_max,
        'contrast_ratio': orion_contrast,
        'shape': orion_patch.shape
    }
    
    # Cross-correlation for alignment assessment
    if he_patch.ndim == 3:
        he_gray = cv2.cvtColor(he_patch, cv2.COLOR_RGB2GRAY)
    else:
        he_gray = he_patch
    
    # Ensure same size
    if he_gray.shape != orion_patch.shape:
        he_gray = cv2.resize(he_gray, orion_patch.shape[::-1])
    
    correlation = np.corrcoef(he_gray.flatten(), orion_patch.flatten())[0, 1]
    analysis['alignment'] = {
        'correlation': correlation
    }
    
    return analysis

def visualize_training_pairs(pairs_dir: str, num_samples: int = 8, save_path: str = None):
    """Visualize training pairs with quality assessment."""
    
    # Find training pairs
    pairs = find_training_pairs(pairs_dir, max_pairs=num_samples)
    
    if not pairs:
        print("No training pairs found!")
        return
    
    print(f"Found {len(pairs)} training pairs to visualize")
    
    # Create figure
    fig = plt.figure(figsize=(20, 4 * len(pairs)))
    
    overall_stats = {'correlations': [], 'he_contrasts': [], 'orion_contrasts': []}
    
    for i, (he_path, orion_path, patch_id) in enumerate(pairs):
        try:
            # Load training pair
            he_patch, orion_patch = load_training_pair(he_path, orion_path)
            
            # Analyze content
            analysis = analyze_patch_content(he_patch, orion_patch)
            overall_stats['correlations'].append(analysis['alignment']['correlation'])
            overall_stats['he_contrasts'].append(analysis['he']['contrast_ratio'])
            overall_stats['orion_contrasts'].append(analysis['orion']['contrast_ratio'])
            
            # Create overlay
            overlay = create_overlay(he_patch, orion_patch)
            
            # Plot row
            row = i + 1
            
            # H&E patch
            plt.subplot(len(pairs), 4, (i * 4) + 1)
            if he_patch.ndim == 3:
                plt.imshow(he_patch)
            else:
                plt.imshow(he_patch, cmap='gray')
            plt.title(f'H&E - {patch_id}\nMean: {analysis["he"]["mean_intensity"]:.1f}\nContrast: {analysis["he"]["contrast_ratio"]:.3f}')
            plt.axis('off')
            
            # Orion patch
            plt.subplot(len(pairs), 4, (i * 4) + 2)
            plt.imshow(orion_patch, cmap='hot')
            plt.title(f'Orion (Protein)\nMean: {analysis["orion"]["mean_intensity"]:.1f}\nMax: {analysis["orion"]["max_intensity"]:.1f}')
            plt.axis('off')
            
            # Overlay for alignment check
            plt.subplot(len(pairs), 4, (i * 4) + 3)
            plt.imshow(overlay)
            plt.title(f'Overlay (R=H&E, G=Orion)\nCorrelation: {analysis["alignment"]["correlation"]:.3f}')
            plt.axis('off')
            
            # Intensity profiles
            plt.subplot(len(pairs), 4, (i * 4) + 4)
            
            # Sample a row from the middle for intensity comparison
            mid_row = he_patch.shape[0] // 2
            
            if he_patch.ndim == 3:
                he_profile = np.mean(he_patch[mid_row, :, :], axis=1)
            else:
                he_profile = he_patch[mid_row, :]
            
            orion_profile = orion_patch[mid_row, :]
            
            # Normalize profiles for comparison
            he_profile_norm = (he_profile - he_profile.min()) / (he_profile.max() - he_profile.min()) if he_profile.max() > he_profile.min() else he_profile
            orion_profile_norm = (orion_profile - orion_profile.min()) / (orion_profile.max() - orion_profile.min()) if orion_profile.max() > orion_profile.min() else orion_profile
            
            plt.plot(he_profile_norm, label='H&E (norm)', alpha=0.7)
            plt.plot(orion_profile_norm, label='Orion (norm)', alpha=0.7)
            plt.title('Intensity Profiles (Middle Row)')
            plt.legend()
            plt.grid(True, alpha=0.3)
            
        except Exception as e:
            print(f"Error processing pair {patch_id}: {e}")
            continue
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"Visualization saved to: {save_path}")
    
    plt.show()
    
    # Print overall statistics
    print("\n" + "="*50)
    print("OVERALL TRAINING PAIR STATISTICS")
    print("="*50)
    print(f"Number of pairs analyzed: {len(overall_stats['correlations'])}")
    print(f"Mean correlation: {np.mean(overall_stats['correlations']):.3f} ± {np.std(overall_stats['correlations']):.3f}")
    print(f"Mean H&E contrast: {np.mean(overall_stats['he_contrasts']):.3f} ± {np.std(overall_stats['he_contrasts']):.3f}")
    print(f"Mean Orion contrast: {np.mean(overall_stats['orion_contrasts']):.3f} ± {np.std(overall_stats['orion_contrasts']):.3f}")
    
    # Quality assessment
    good_correlation = sum(1 for c in overall_stats['correlations'] if c > 0.1)
    print(f"Pairs with positive correlation: {good_correlation}/{len(overall_stats['correlations'])} ({100*good_correlation/len(overall_stats['correlations']):.1f}%)")
    
    high_he_contrast = sum(1 for c in overall_stats['he_contrasts'] if c > 0.2)
    print(f"H&E patches with good contrast: {high_he_contrast}/{len(overall_stats['he_contrasts'])} ({100*high_he_contrast/len(overall_stats['he_contrasts']):.1f}%)")
    
    high_orion_signal = sum(1 for stats in overall_stats['orion_contrasts'] if stats > 0.1)
    print(f"Orion patches with signal: {high_orion_signal}/{len(overall_stats['orion_contrasts'])} ({100*high_orion_signal/len(overall_stats['orion_contrasts']):.1f}%)")

def main():
    """Main function to visualize training pairs."""
    
    # Default path from your pipeline output
    pairs_dir = "output/registration_output/training_pairs"
    
    # Check if directory exists
    if not os.path.exists(pairs_dir):
        print(f"Training pairs directory not found: {pairs_dir}")
        print("Please update the pairs_dir variable with the correct path.")
        return
    
    print(f"Visualizing training pairs from: {pairs_dir}")
    
    # Visualize pairs
    visualize_training_pairs(
        pairs_dir=pairs_dir,
        num_samples=8,  # Show 8 sample pairs
        save_path="training_pairs_visualization.png"
    )

if __name__ == "__main__":
    main() 